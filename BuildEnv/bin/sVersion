#!/usr/bin/env ruby

require 'docopt'
require 'logger'
require 'yaml'

# Handles everything version related
class Version
  def initialize(yml_file, av_dir = 'src')
    if( File.file?(yml_file) )
      @yml_file = yml_file
      @yml = YAML.load_file(@yml_file)

      $logger.debug @yml

      # work out autoversion directory
      @av_dir = av_dir
      update_autoversion_directory
    else
      $logger.fatal "#{yml_file} not found, please create."
      $logger.fatal "See: http://sanpgit01.schrader.local/tools/buildenv/wikis/sVersion#setting-up-projectyml"
      exit 1
    end

    @msn = @yml['versionInfo']['msn']
    @major = @yml['versionInfo']['major']
    @patch = @yml['versionInfo']['patch']
    @verification = @yml['versionInfo']['verification']
    $logger.warn "yml releaseType redundant and can be removed from yml file" if @yml['versionInfo']['releaseType']

    # Note release type is now determined by current branch
    @release_type = exp_release_type

    # use CI Build Id if aviliable, otherwise use 0
    @build_id = ENV['CI_BUILD_ID'] || '0'

    @rel_type_lookup = {}
    @rel_type_lookup['RC'] = 'SEL_RELEASE_CANDIDATE'
    @rel_type_lookup['SR'] = 'SEL_SPECIAL_RELEASE'
    @rel_type_lookup['A'] = 'SEL_ALPHA_RELEASE'
    @rel_type_lookup['B'] = 'SEL_BETA_RELEASE'

    @release_enum = @rel_type_lookup[@release_type]
  end

  def quick_check
    check_format
    check_dups
  end

  def full_check
    check_format
    check_dups
    check_branch
  end

  def tag
    tag_cmd = "git tag -a #{tag_name} -m \"Release of version #{tag_name}\""
    push_cmd = "git push origin #{tag_name}"
    puts `#{tag_cmd}`
    puts `#{push_cmd}`
    $logger.info "Tagged #{tag_name}"
  end

  def update(new_version)
    # parse, expecting Version number in standard Sensata format without release type e.g. X.Y.Z
    m = new_version.match(/(?<major>\d{1,3})\.(?<patch>\d{1,3})\.(?<verification>\d{1,3})/)

    if m
      @major = m['major'].to_i
      @patch = m['patch'].to_i
      @verification = m['verification'].to_i

      # Note release type is now determined from git branch

      if check_format
        # format is OK, write back to yml file
        @yml['versionInfo']['major'] = @major
        @yml['versionInfo']['patch'] = @patch
        @yml['versionInfo']['verification'] = @verification
        File.open(@yml_file, 'w') { |f| f.write @yml.to_yaml } # Store
      end
      $logger.info "Updated yml file to #{@major}.#{@patch}.#{@verification}"
    else
      log_error "Failed to parse #{new_version}, ensure correct format is used e.g X.Y.Z"
    end
  end

  def verify_tag
    tag_created = false
    tags = `git tag`.split"\n"
    if tags.include? tag_name
      tag_created = true
    else
      log_error 'verify tag failed'
    end

    $logger.info "Verified tag #{tag_name}"

    tag_created
  end

  # creates an autoversion.h header file
  def autoversion
    versions =
                  "/*! Versions generated by #{File.basename($PROGRAM_NAME)} on #{Time.now.strftime("%Y-%m-%d %H:%M")} */\n" \
                  "/*! \\note this generated file should NOT be added to Git repository, include in .gitignore to avoid */\n" \
                  "\#ifndef AUTOVERSION_H\n" \
                  "\#define AUTOVERSION_H\n\n" \
                  "\#include \"C_defs.h\"\n\n" \
                  "#define #{@msn}_VERSION_MAJOR          ( #{@major}u )\n" \
                  "#define #{@msn}_VERSION_PATCH          ( #{@patch}u )\n" \
                  "#define #{@msn}_VERSION_VERIFICATION   ( #{@verification}u )\n" \
                  "#define #{@msn}_VERSION_RELEASE_TYPE   ( #{@release_enum} )\n" \
                  "#define #{@msn}_BUILD_ID               ( #{@build_id} )\n\n" \
                  "\#endif"

    version_header = "#{@av_dir}/autoversion.h"
    File.open(version_header, 'w') { |file| file.write(versions) }
    $logger.info "Generated #{version_header} with #{to_s}"
  end

  def tag_name
    "#{@major}.#{@patch}.#{@verification}.#{@release_type}"
  end

  def full_name
    "#{@tag_name}-#{@build_id}"
  end

  private

  # translates Release type abbreviation to a full name
  def release_type_name
    case @release_type
    when 'RC' then name = 'Release Candidate'
    when 'B' then name = 'Beta'
    when 'A' then name = 'Alpha'
    when 'SR' then name = 'Special Release'
    end
    name
  end

  # Check for duplicates
  def check_format
    if @major.between?(0, 255) && @patch.between?(0, 255) && @verification.between?(0, 255)
      $logger.debug 'Release numbers OK'
    else
      log_error "Release numbers of #{@major}, #{@patch}, #{@verification} are invalid"
    end

    if !@release_enum.nil?
      $logger.debug 'Release Type OK'
    else
      log_error "Release Type of #{@release_type} is invalid"
    end

    $logger.info 'Format OK'

    true
  end

  # Check for duplicates
  def check_dups
    tags = `git tag`.split"\n"
    if tags.include? tag_name
      log_error 'tag already exists'
    end
  end

  def sgitflow_branch_type
    # if being build by GitLab CI then use reference name to work out the branch
    # can't use 'git rev-parse' since GitLab checks out a detached head
    if ENV['CI_BUILD_REF_NAME']
      branch = ENV['CI_BUILD_REF_NAME']
    else
      branch = `git rev-parse --abbrev-ref HEAD`.chomp
    end

    $logger.debug "branch: #{branch}"
    sgitflow_type = branch.split('/').first
  end

  # Works out the expected release type from the current git branch
  def exp_release_type
    case sgitflow_branch_type
    when 'master', 'release', 'hotfix'
      release_type = 'RC'
    when 'develop'
      release_type = 'B'
    else
      # if trigger by a server side release then use Special Release, everything else is Alpha
      release_type = 'A'
      release_type = 'SR' if ENV['CI_BUILD_TAG'] && (ENV['CI_BUILD_TAG'].include? 'RelReq')
    end
    release_type
  end

  # Checks if the release type corresponds to correct sgit-flow branch type
  def check_branch
    sgitflow_type = sgitflow_branch_type

    case @release_type
    when 'RC'
      # only allowed on master branch
      log_error('RC release only allowed on master branch') unless sgitflow_type == 'master'
    when 'B'
      # only allowed on develop branch
      log_error('Beta release only allowed on develop branch') unless sgitflow_type == 'develop'
    when 'A', 'SR'
      # not allowed on master or develop branches
      if sgitflow_type == 'master' || sgitflow_type == 'develop'
        log_error("#{release_type_name} release not allowed on master or develop branches")
      end
    else
      log_error("#Unknown releaseType@ #{@release_type}")
    end
  end

  # reads version information from a given source file
  def source_code_version(file_name)
    text = File.read(file_name)
    info = {}
    text.split("\n").each do |line|
      case line
      when /.*VERSION_MAJOR.*(?<major>[\d]{1,3})/
        info[:major] = Regexp.last_match[:major].to_i
      when /.*VERSION_PATCH.*(?<patch>[\d]{1,3})/
        info[:patch] = Regexp.last_match[:patch].to_i
      when /.*VERSION_VERIFICATION.*(?<verification>[\d]{1,3})/
        info[:verification] = Regexp.last_match[:verification].to_i
      when /.*VERSION_RELEASE_TYPE.*( (?<release_type>\w+) )/
        info[:release_type] = Regexp.last_match[:release_type]
      end
    end
    info
  end

  # work out autoversion directory
  def update_autoversion_directory
    if Dir.exist?(@av_dir.to_s)
      # leave as is
    elsif Dir.exist?('src')
      @av_dir = 'src'
    else
      @av_dir = '.'
    end
    $logger.debug "Autoversion dir: #{@av_dir}"
  end

  def to_struct
    "{ #{@major}u, #{@patch}u, #{@verification}u, #{@release_enum} }"
  end

  def to_s
    "#{tag_name}-#{@build_id}"
  end

  def log_error(message)
    $logger.error message
    exit 1
  end
end

if $PROGRAM_NAME == __FILE__

  # ***************************************************************************************************
  #   \brief          Main Program
  # ***************************************************************************************************
  # Grab just the filename for convenience
  NAME = File.basename($PROGRAM_NAME)
  PTLD = File.expand_path(ENV['PTLD'])
  PROJECT_YML = File.expand_path(ENV['PTLD']) + '/project.yml'

  # Version information string
  VERSION_NUM = '1.3.0.RC'.freeze
  VERSION = <<END_VERSION.freeze
########################################################################
#  #{NAME} #{VERSION_NUM}
#  Version tool check and tag repo with version info from versions yml:
#  #{PROJECT_YML}
#
#  Copyright (C) 2016 Sensata Technologies.
########################################################################
END_VERSION

  # Build the options!  Notice that #{VERSION} will include a newline at end
  DOC_OPT = <<DOCOPT.freeze
#{VERSION}
Usage:
  #{NAME} [-alct]
  #{NAME} -a AUTOVERSION_DIR
  #{NAME} [-u] VERSION
  #{NAME} -h | --help
  #{NAME} --version

Arguments:
  AUTOVERSION_DIR   Autoversion Directory
  VERSION           Version number in standard Sensata format e.g. X.Y.Z.RC

Options:
  -a --autoversion  Creates an autoversion header file
  -c --check        Checks that version number is valid
  -h --help         Show this screen.
  -l --list         Lists version number
  -t --tag          Tags repo with current version number
  -u --update       Updates version number in #{File.basename(PROJECT_YML)}
  -v --version      Show version.

Depreciated and Obsolete Options:
  -i --inject       Use autoversion instead then include header within project

User Manual: http://sanpgit01.schrader.local/tools/buildenv/wikis/sVersion
DOCOPT

  $logger = Logger.new($stdout).tap do |log|
    log.progname = NAME.to_s
  end

  # simplify logger output format
  $logger.formatter = proc do |severity, _datetime, _progname, msg|
    "#{severity}: #{msg}\n"
  end

  $logger.level = Logger::INFO

  # Extract options!
  options = {}
  begin
    options = Docopt.docopt(DOC_OPT)
  rescue Docopt::Exit => e
    puts DOC_OPT
    exit 1
  end

  $logger.debug options

  version = Version.new(PROJECT_YML, options['AUTOVERSION_DIR'])

  puts version.tag_name if options['--list']

  version.quick_check if options['--check']

  if options['--autoversion']
    # note: no need for checks on autoversion
    version.autoversion
  end

  if options['--tag']
    version.full_check
    version.tag
    version.verify_tag
  end

  if options['--update']
    version.update options['VERSION']
  end

  exit 0
end
